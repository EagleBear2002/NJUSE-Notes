# 题型

10道单选题：每个方向平均

4道简答题：每个方向至少一道题，题目相对开放，多写一点

3道大题

- 测试用例选择 测试用例优先级 计算题
- 移动测试部分 设计题 把PPT上或课堂上提到的或在论文里看到的内容做一个简单复现
- AI测试部分

## 1.源码测试

### 1.1回归测试

1. 软件产品在开发和维护相关过程中，因移除软件内在缺陷、完善已有功能、重构已有代码、提高运行性能等，需要执行代码修改并触发软件演化。而随着以同一过程和敏捷方法为代表的的增量迭代式开发过程的流行，软件演化频率也随之迅速提高，并急需经济有效的测试方法，来确保演化后软件产品的质量

2. **基本概念**：版本迭代后，重新执行测试用例。回归测试可有效保证代码修改的正确性，并避免代码修改对被测试程序的其他模块产生副作用。

3. 常用的回归测试方法：重新执行之前积累的测试用例

   问题

   - 用例庞大（运行时间长）
   - 用例冗余（有功能相似或相同用例）
   - 用例失败（代码修改影响到了被测模块原有的外部接口或内在语义）
   - 用例缺失（代码修改会后新的测试需求）

4. 回归测试优化 ![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/865E02A78BE8CE36D28367122252F97D.png)

   测试用例选择：通过分析代码修改，从已有测试用例中选择出所有可检测代码修改的测试用例，并确保未被选择的测试用例在修改前后程序上的执行行为保持一致

   测试用例优先级：当测试预算不足以执行完所有测试用例时，基于特定的优先级准则，对测试用例进行优先级排序，以优化其执行次序，旨在最大化优先级目标

5. 差分测试：通过向⼀系列类似的程序（或同⼀程序的不同实现）提供相同的输⼊，并观察它们执⾏过程中的差异，来检测BUG。

   - 适合于发现语义或逻辑错误，这些错误不会表现出明显的错误⾏为，如崩溃或断⾔失败。

   - 差分测试通过使⽤相同功能的不同实现⽅法的程序来测试语义BUG，在多次输⼊中找出输出和过程上⾯的不同。同⼀输⼊上的不同程序⾏为之间的任何差异都被标记为潜在的BUG。

6. 蜕变测试（大概了解）：依据被测软件的领域知识和软件的实现⽅法建⽴的蜕变关系来⽣成新的测试⽤例,通过验证蜕变关系 是否被保持来决定测试是否通过。(sinx=sin(pi-x))

   蜕变关系(Metamorphic Relation, MR) 是指多次执⾏⽬标程序时,输⼊与输出之间期望遵循的关系

   eg. ⼀个程序可以算sin，sin (270) = sin ( - 270)，测试时将两者分别计算并比较

7. **变异测试（重点）：**通过定义好的变异操作来对源码进⾏修改,以此来帮助测试者定位测试数据的弱点,避免执⾏测试的弱点 

### 1.2测试用例优先级(TCP)

1. 定义：通过设定特定的优先级准则（执行带啊、代码覆盖等），对测试用例进行优先级排序以优化其执行次序，旨在最大化优先级目标（如今早发现检测到缺陷）
2. 流程![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/8564A3A7EFCB656370EBC2B54BD990C2.png)![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/F335B60B255824D264E9A51870066E69.png)
   - 特征提取：对特使用例进行特征表示
     - 代码覆盖：语句覆盖、分支覆盖、函数覆盖
     - 基于文本特征提取：计算测试诗句文本（如字符串或向量）之间的差异性（海明距离、曼哈顿距离、编辑距离）来表示特征
     - 基于缺陷特征提取：使用缺陷相关的特征来表示测试用例（如在变更代码上使用变异测试，使用变异体的检测能力来度量真实的缺陷检测能力）
     - 基于模型特征提取
   - TCP策略：基于测试用例的特征进行优先级排序
     - 基于贪心：全局贪心、额外贪心
     - 基于相似性：基于缺陷(bug)在程序的行为空间中的分布特征，程序的缺陷往往聚集在程序的行为空间中->自适应TCP
     - 基于搜索：探索用例优先级排序组合的状态空间，以找到检测错误更快的用例排序
     - 基于机器学习
   - 评估准则：选择恰当指标评估优先级排序的效果
     - 性能：错误检测率
     - 开销：时间开销

#### 1.2.1TCP策略

1. **全局贪心算法**

   每轮优先挑选覆盖最多代码单元的测试用例。

   如果每轮存在n个测试用例满足要求，则从中随机选择![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/84CC3BC69473CC412EBEEAC38B547ED2.png)

   集合T：待排序测试用例集，初始时存放被测程序的整个测试用例（输入）

   集合S：已排序测试用例集，初始时为空集（输出）

   m个代码单元，n个测试用例

   流程：

   - 首先根据每一个待排序测试用例对每一个语句的覆盖情况通过Cover数组来获得，计算测试用例所覆盖的代码单元数量，存储在TCTimes数组中
   - 之后对待排序的测试用例，比较他们覆盖代码单元的数量，从中选择覆盖数量最大的测试用例
   - 将其添加到S中
   - 从T中删除该用例
   - 重复以上3步直到T为空集，输出S

2. **额外贪心算法**

   每轮优先挑选覆盖最多，且未被已选择用例覆盖代码单元的测试用例

   所有代码单元均已被覆盖则重置优先级排序过程

   如果每轮存在n个测试用例满足要求，则从中随机选择

   ![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/3C017F96C75275F4F7AF6AC857D07D9D.png)

   集合T：待排序测试用例集，初始时存放被测程序的整个测试用例（输入）

   集合S：已排序测试用例集，初始时为空集（输出）

   m个代码单元，n个测试用例

   UnitCover数组：存储每个代码单元是否被覆盖

   流程：

   - 对每一个待排序测试用例，计算：该测试用例覆盖了、且尚未被已排序测试用例集覆盖的代码单元的个数，作为本轮该测试用例的评估指标
   - 得到所有待排序测试用例的评估值后，从中选择具有最大评估值的测试用例放入S中，从T中删除它（若存在多个测试用例同时满足要求，则在其中随机挑选一个）
   - 更新UnitCover数组
   - 重复以上3个步骤，直到T为空集。如果中途所有代码单元都已经被覆盖，则重置：将所有代码单元的覆盖情况设为未被覆盖

   eg.![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/1474092DB717066FBEC9DE15B08449B9.png)

3. 自适应随机策略（基于相似性的TCP）

   - 每轮优先与已选择的测试用例差异性最大的测试用例，让测试用例均匀地分布在输入域中![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/9049ABD06F822C4D58FE6AEB13C086CD.png)
     - 首先迭代选择测试用例，形成候选测试用例集
     - 然后计算每一个候选测试用例与已排序测试用例集的距离，选择具有最远距离的测试用例，进入已排序测试用例集中
     - 直到所有测试用例集都被选择，结束排序

   - 如何定义测试用例之间的相似性：
     - 计算测试用例之间的距离：假设U(t1)和U(t2)为测试用例t1和t2所覆盖的代码单元集合，那么距离计算如下![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/6A4A8566BFF0FA364A2BE1458DDCF4D7.png)
     - 计算候选测试用例到已排序测试用例集之间的距离：分别可以使用最小距离(tc与S中各个用例的距离的最小值)、平均距离、最大距离度量方式，代表候选用例tc与已选择用例集S的距离![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/C0629B70746F13CBA7E84051D5B86581.png)
     - 
   - eg.![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/6CE1056E3CADDA3A5B48B22018826254.png)
     - 随机构造候选集C={t1,t4},随机选则S={t1}
     - 随机构造候选集C={t4,t5},d(t1,t5)=0.2,d(t1,t4)=0.3，0.3>0.2选择t4，所以S={t1,t4}
     - 随机构造候选集C={t6,t7},d(t1,t6)=0.2,d(t4,t6)=0.3,d(t1,t7)=0.3,d(t4,t7)=0。
     - 在最小度量(通常选)下0.2>0选t6，平均度量下0.25>0.15选t6，最大度量下0.3=0.3选t7

4. 基于搜索的策略![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/64708EA0D51A52D283CA224FAF6583C3.png)

   流程：

   - 种群构造：生成N个测试用例序列，解的编码形式为优先级排序的测试用例编号位置![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/85468887EF0C42199295718C08DFBBE9.png)
   - 交叉：使用单点交叉的的方式，随机生成切割垫，互相交换两个用例序列切割后部分的片段，仅交换相同测试用例的部分![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/43ED278E1BE6273465D63DBDAD9429D5.png)
   - 变异：对种群中的个体进行基因值的改变操作。以一定概率选择测试用例，并随机生成两个测试用例位置，进行互换，产生新的测试用例序列![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/AF3BF3D70BACF61B69EB3A5A291C1260.png)
   - 评估值计算：以语句覆盖为例，给定程序包含m个语句M={s1,s2,...,sm}和n个测试用例T={t1,t2,...tn},T'为某一次搜索中的优先级序列，TSi为该测试用例序列T'中第一个覆盖语句Si的测试用例下标，其适应度计算为：![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/CCEFA86695A15D8FB58618FE34C01F9B.png)

5. 基于机器学习的TCP策略 

   定义：基于测试分布特征，预测表现最佳的排序技术。 

   流程： 

   - 测试分布特征提取：给定被测程序，提取每个测试⽤例覆盖单元数；执⾏时间与单元时间内覆盖单元数。 
   - 模型⽣成：由于三种特征取值范围不同，使⽤min-max正则化，最后使⽤XGBoost学习特征进⾏预测。

#### 1.2.2评估指标

1. **APFD（非常重要）**（平均故障检测百分比）
   - 定义：当给定测试用例的执行次序，该指标可以给出测试用例执行过程中检测到缺陷的平均累计比例。(默认每一个测试用例具有相同的时间开销)
   
   - 特点：取值范围在0~100%之间，取值越高，则缺陷检测速度越快![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/F94BDF79DB49CE227CB90ACC6C44387B.png)
   - eg.APFD：阴影面积占整个面积的百分比![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/E2042B5B78B4D18CF2BABCD0E97209A0.png)
   
2. APFDc（开销检测故障百分比）

   - 特点：考虑了测试用例的执行开销和缺陷危害程度![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/BB4980F58EDB9E42621AE6E4097F5446.png)

3. NAPFD（归一化平均故障检测比）

   - 特点：考虑了实际优先级排序场景中，①测试用例集不能检测到所有缺陷②由于资源限制，无法执行所有测试用例![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/93DB0B959108976775CB0F56A333119B.png)

### 1.3测试用例选择(TCS)

1. 旨在从已有测试用例集中选出所有可检测代码修改的测试用例

2. 目标：
   - 减少回归测试需要执行的用例数量，节约时间，降低开销
   - 排除部分无关的测试用例，保留执行后能暴露软件缺陷的测试方法，用最少的测试用例达到最大化缺陷探测能力的效果
   
3. 流程![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/660268DF283C03F3D217EF1E0183E6D2.png)

4. 主要方法

   - 最小化测试用例选择

     - 从中找出最⼩的⼦集 Tmin, Tmin 能够覆盖P$中所有本次修改的、或者受本次修改影响的部分。 

     - 每⼀条新增的或者被修改的语句都能够被⾄少⼀个来⾃ 的测试⽤例执⾏。 

   - 安全测试用例选择

     - 从T中选出能够暴露P'中的⼀个或多个缺陷的所有测试⽤例，构成安全回归测试集Ts

     - Ts 中的每个测试都能够满⾜以下条件之⼀:

       ①执⾏⾄少⼀条在P'中被删除的语句 

       ②执⾏⾄少⼀条在P‘中新增的语句

   - 基于数据流和覆盖的测试用例选择

     - 变更后的代码P'中使数据交互变化的语句构成语句集合Si 。从原本的测试⽤例集T中选取出所有覆盖到Si中某条语句的测试⽤例，组成测试集Td

     - Td中的每个测试都能够满⾜以下条件之⼀ 

       ①执⾏⾄少⼀个在P’中被删除的Define-Use对 

       ②执⾏⾄少⼀个在P‘中新增的Define-Use对

   - 特质/随机测试用例选择

     - 规定测试⽤例的选取数量为m，测试⼈员随机地从原本的测试⽤例集 T中选出m个测试⽤例，组成随机回归测试集 Tr

       ⾯向剖⾯测试⽤例选择：与AOP有关，从T中选出与某个剖⾯a有关的测试⽤例k，组成回归测试集

#### 1.3.1基于程序分析的测试选择：

1. 含义：通过程序分析技术计算测试代码（方法、用例或套件）与生产代码之间存在的依赖关系，在代码发生变更是，利用这些依赖关系取出受到变更影响的测试代码，组成测试子集（安全测试用例选择）

2. 阶段：
   - 变更分析：确定发生变更的生产代码，获取变更信息
   - 依赖分析：分析代码中存在的依赖关系。获取测试依赖（测试代码由于调用了某些生产方法而产生的关联关系）
   - 测试筛选：根据变更信息和测试依赖，筛选受变更影响的测试方法![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/1F53270DDADBFD765E7AE123130FCD00.png)
   
3. 分类：**静态、动态**

   - 静态测试选择：以静态程序分析为基础实现的测试选择技术

     - 静态程序分许是指在**没有实际执行程序**的情况下对计算机软件程序进行自动化分析的技术。
     - 分析材料：源代码（主要）、目标语言代码。eg.分析java字节码

   - 动态测试选择：以动态程序分析为基础实现的测试选择技术

     - 动态程序分析通过**在真实或虚拟处理器上执行程序**来完成对程序行为的分析。
     - 为了使动态程序分析有效，必须使用足够的测试输入来执行目标程序，以尽可能覆盖所有的输出
     - 进行动态分析时一般需要注意最小化插桩对目标程序的影响

   - 对比：

     - 动态测试选择一般优于静态测试选择：动态分析更容易获得更丰富的（运行时信息）程序依赖信息，测试选择更精准、安全；静态分析开销更大，且存在过拟合现象

     - 静态测试选择技术在运行测试阶段的表现一般优于动态测试选择技术：静态分析不需要对代码进行插桩，在执行代码前就能获得测试选择所需要的测试依赖

       ![1](https://seek2.oss-cn-shanghai.aliyuncs.com/img/1.png)

4. 粒度

   - 细粒度

     - 基本块（Basic Block，BB）级：利⽤BB级变更和BB级测试依赖进⾏测试选取

     - ⽅法级：利⽤⽅法级变更和⽅法级测试依赖进⾏测试选取

   - 粗粒度

     - ⽂件（类）级：利⽤⽂件级变更和⽂件级测试依赖进⾏测试选取。由于Java语⾔会将每⼀类编译成⼀个.class⽂件，因此针对Java语⾔的⽂件级测试⽤例选择等同于类级别测试⽤例选择
     - 项⽬（模块）级：利⽤项⽬级变更和项⽬间依赖进⾏测试选取

5. 流程

   A Phase – 分析阶段：分析代码变更、计算测试依赖

   E Phase – 执⾏阶段：运⾏选中测试

   C Phase – 收集阶段：收集测试信息。按照产⽣的时间点不同，信息可以分成两类：运⾏时信息（动态测试依赖、覆盖信息）和测试运⾏结果（测试运⾏结果、测试运⾏时间）

   三阶段（Offline Mode）：A -> E -> C，执⾏测试和收集信息分开进⾏。测试需要运⾏两遍，但是能够更早得到测试反馈

   两阶段（Online Mode）：A -> EC，在执⾏测试的同时收集信息。延⻓了测试执⾏时间，但总时间更短

#### 1.3.2基于依赖分析的测试用例选择方法：类防火墙算法

1. 含义
   - 假设在继承层级(Inheritance Hierarchy)中,类A是类B的⼦类。当有且仅有B发⽣变动时,为了保证 测试充分,除B之外,A也应该重新进⾏单元测试。 
   - 假设在聚合层级(Aggregation Hierarchy)中,类A是类B的⼀个聚合类。当有且仅有B发⽣变动时,为 了保证测试充分,除B之外,A也应该重新进⾏单元测试。 
   - 假设在关联层级(Association Hierarchy)中,类A与类B的关系满⾜下列条件之⼀:① 类A访问了类B的数据成员; ②类A需要向B传递信息 (简⾔之: A依赖B)。当B发⽣变动时,为了保证测试充分,除B之外,A也应该重新进⾏测试。同时,类A还应该与类B进⾏重新集成。 
2. 特点：
   - 构造出的图更小，计算开销小
   - 会选入许多无关的测试方法，精度较低
   - 选用较多的测试方法同时意味着不容易发生测试方法遗漏，测试选择的安全性相对更高

#### 1.3.4测试用例优先级 **V.S.** 测试用例选择 

1. 优先级技术是对测试⽤例集进⾏排序,以最快的速度找到缺陷,提⾼测试⽤例集的故障检测率。 
2. 选择技术是取测试⽤例集的⼦集,能覆盖修改过的代码,降低回归测试的开销并最⼤化缺陷探测能⼒ 

## 2.移动应用

### 2.1基于图像理解的移动应用自动化测试（重要）

1. 安卓自动化GUI测试：用于解决安卓框架的碎片化所导致的各方面问题。
   - 方法一：安卓自动化测试框架
     - 由专业技术人员编写能够借由框架进行重复性执行的脚本
     - 局限：①测试脚本需要又掌握专业技能的技术人员编写②大型测试平台上测试框架的选择较为匮乏
   - 方法二：自动化测试工具
     - 无需任何人工操作就可以自动地对一款应用进行遍历
     - 通过对应用内容的大面积覆盖，来触发应用中可能出现的bug
     - 局限：①弹窗问题、回退问题、控件组合型问题②无法做到控件的全覆盖
   - 自动化GUI测试现存问题：
     - 现存的自动化测试方法（如以上两种）仍然无法完全解决大部分人类可以轻易解决的问题
     - 只进行一轮的测试流程就得出测试结果，因为控件优先级而被忽略的低优先级的页面会被永源地遗弃
   - 迭代式人机融合自动化测试

#### 2.1.1测试脚本录制回放

1. 移动平台的碎片化问题：平台多样、操作系统版本、品牌、型号、屏幕尺寸分辨率......页面会呈现不同的效果，使得测试脚本不能简单地复制粘贴使用→期望提供一种技术：当在A上跑过的测试流程可以在另外的设备B、C、D也正确地运行→**在A上进行脚本录制，在B C D上进行脚本回放**（GUI测试脚本录制与回放：大多数移动应用在不同平台上设计的UI布局结构极为相似，因此可以利用这种相似性进行移动应用的GUI测试脚本的录制与回放）

   ![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/B298F1543A4240E0CA157A7CDD1AE621.png)

   录制回放的过程中脚本的结构模型：

   ![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/57926751145697E43B02B932EC7BACC7.png)

2. GUI脚本录制：

   - 基于坐标：录制内容为用户的动作和相应的点击坐标
   - 基于控件树(主流)：对UI控件树进行解析，以控件的唯一标识(如xpath)对控件进行定位
   - 基于图像：对比控件截图与屏幕截图从当前UI定位控件

3. GUI脚本回放：

   - 图像的特征比对![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/F266EE262ED6E1814177C02A48B79E7C.png)
   - 布局刻画![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/7600D3DB199241101DDAE4D99ACD37FF.png)
   - 坐标校正![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/5AFDF11BE3C179EA4C882E022D734FF7.png)

#### 2.1.2众包测试报告排序

1. 众包测试

   - 指将移动应用测试任务分发给众多众包工进行测试，移动应用测试众包报告包含少量文本+多张bug截图
   - 优势：可以向开发者提供多种不同软硬件平台支持的真实用户数据和操作信息
   - 问题：测试报告数量庞大、人工审查过于耗时

   ​            →为开发者提供一种定义和排序移动应用测试报告的技术

   - 普通测试报告与移动应用测试报告：
     - 对于普通测试报告的排序技术：主要关注测试报告的文本描述或程序代码的执行树
     - 移动应用测试报告的排序应同时将**缺陷截图和文本**描述纳入考虑

   - 排序报告原则：尽可能早地发现有缺陷的报告，提高报告的审查效率

2. 排序技术：使用文本+图片结合分析的方法![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/6D0B576FF462A0FFB204631DB48F4553.png)

   - 通过自然语言处理算法计算本文相似度
   - 通过SPM算法识别缺陷截图相似度
   - 通过使用一种多目标的优化算法结合文本与截图相似度完成针对测试报告的相似度比较

3. 文本处理：

   - 关键词提取
     - 使用LTP平台进行文本的切割来处理中文描述
     - 根据上下文标记每个词的词性：LTP通过CRF来分词并采用SVM来标记词性
     - 过滤无用词汇：这些词会对文本距离计算产生消极影响，根据众包测试停用词表进行过滤

   - 文本距离的计算
     - ![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/7CBBD885D1278CD8C59A335AC74E7FE9.png)

4. 截图处理

   - 建立特征直方图
     - 将图片转化为特征向量便于计算
   - 计算截图之间的距离
     - 由于移动应用的界面跟app强相关，不且有各种恶样的分辨率和背景，使用简单的RGB分析不能满足需求
     - 使用SPM算法![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/1352D80B58D7674DC211E0647226966F.png)
   - 计算截图集合之间的距离
     - 为了解决移动设备多样性，尤其是分辨率多样性，设定阈值γ来评估不同设备同一页面截图![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/A96509C545413E29DAFD5D4420351234.png)
     - 在完成测试报告内部的筛选工作之后，再通过阈值γ在测试报告的截图合集之间进行筛选![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/18F630563D213DEED7BD508DB5741CB1.png)

5. 图文结合![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/C5CC29920492DE34D2207F18E0940CB0.png)

#### 2.1.3深度众包测试报告排序

1. 问题
   - 被提交上来的大量报告中，有很多针对的的bug是重复的
   - 文本：同样的问题可以通过不同的描述来编写，主观性较强
   - 截图问题：图片整体UI相似，涉及到bug的部分非常小，判断两份报告到底是否针对同一个bug可能会出现困难（如果用2.1.2的算法）
2. 技术流程![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/DE46364E306F0B7C1E832FB99B1798A6.png)
   - 特征提取
     - 通过计算机视觉（CV）和DL技术提取控件：问题控件(Wp)，上下文控件(Wc)
     - 文本通过NLP技术分解为两部分：复现步骤(R),缺陷描述(P)
   - 特征聚合
     - 建立DeepFeature: ①Bug Feature(BFT)：Wp+P ②Context Feature(CFT)：Wc+R
   - 相似度计算
     - DeepPrior使用DeepFeature计算DeepSimilarity![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/65AAF3BA357B6D1938EA71E29E19E8E7.png)
   - 报告排序
     - 当图像报告距离=0，文本距离*0.75=报告距离
     - 当文本距离和图像距离均≠0，两者的调和平均数=报告距离![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/50891CB790C311A111B6CB610FE41CBF.png)

#### 2.1.4众包测试报告生成

1. 移动应用众包测试报告包括：测试环境、缺陷截图、缺陷描述(唯一会存在问题导致报告低质量的)

   - 低质量的测试报告：
     - 无意义：文本完全是恶意偷懒编写的报告
     - 不想管：报告无法反应真实缺陷
     - 不完整：报告缺陷描述不完整

   - 期望：通过Computer Vision和Deep Learning来综合理解截图，自动生成高质量文本描述

2. 模块![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/567736A1D8579E421CDE24E599664E2B.png)

   - 截图翻译：从截图中提取特征向量，冰菓这些向量生成多个缺陷描述![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/36A289823F2BACD31DB822EDF4CC59F5.png)
   - 文本提取：从截图提取出所有的文本信息，并通过一个预定义的关键词列表来筛选出缺陷相关的文本![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/F61932AE060B993CF1767376D9AA57FD.png)
   - 报告生成：聚类生成文本，最终生成缺陷报告![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/F61932AE060B993CF1767376D9AA57FD.png)

### 2.2基于群智协同的众包测试

1. 移动应用众包测试流程：![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/66AD8C88D03D4AF7B81344429309FEC9.png)
   - 众包任务请求者设计和发布众包任务
   - 众包工人领取并解答测试任务，提交测试报告
   - 众包任务请求者接收和整合测试报告
2. 问题：
   - 众包工人能力水平存在不确定性
   - 开发者面临大量测试报告的审核压力和汇总困难。待审核测试报告均涉及多种测试类型，且具备数量大、专业性强等特点，需要大量具备专业知识的审核人员对待审核测试报告进行审核→如何召集大量具备专业知识的测试人员低成本、高效率地完成测试报告审核？→将众包技术应用于测试报告审核
3. 协作式众包测试系统包括：
   - 推荐系统
   - 质量控制系统：在众包工人测试全过程采取质量控制措施，保证缺陷报告的质量
   - 聚合交付

#### 2.2.1基于用户特征的众包审核任务分配

1. 用户特征：用户信誉特征、用户能力特征、用户行为特征
2. 任务分配
   - 静态任务分配：待审核测试报告生成、静态任务分配（一次将审核任务分配给用户）
   - 动态分配任务：用户（任务的协同过滤算法→获取用户的任务推荐表），任务（任务热度逆序表）![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/6698CC3F245CC1979FC813706FFB00BA.png)
3. 审核结果分析：
   - 分析得出众包审核任务的最终审核结果，输出众包审核报告
   - 根据最终审核报告结果和用户审核结果计算用户绩效，更新用户特征

**协同推荐**

- 信息共享：⽤户在提交报告时进⾏实施实时相似报告推荐，避免重复报告。

- 任务分配：⽤户提交报告后会对其进⾏审核报告推荐和测试⻚⾯推荐，避免部分⻚⾯⽆法被测试。

- 协作⽅式：⽤户对于相似报告和审核报告的推荐结果，可以点赞、踩点，利⽤⽤户的交叉审核，验证报告有效性。

#### 2.2.2面向协作式众包测试的质量保证

众包测试的质量保证是提升测试效率的关键步骤

协作式众包可以欧晓提升众包工人之间的相互协作，从而提升测试任务完成效率![2](https://seek2.oss-cn-shanghai.aliyuncs.com/img/2.png)

1. 缺陷报告有效性检测：提取影响缺陷报告质量的指标，确定质量指标的正副向影响以及有效范围，验证报告有效性![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/7557DAE044BDA2E1D19374AD4A80D2E1.png)

   流程：

   - 分析报告质量指标：分析bug报告基本属性，根据文献，结合协作式众测特点确定质量指标
   - 提取质量报告指标：根据bug报告属性和Chen等人提供的指标字典提取质量指标
   - 指标阶跃变换：根据阶跃变换函数将数值型的指标映射为相应的好与坏等级
   - 测试报告有效性：对指标阶跃变换之后，参考Chen等人判定60%以上指标有效则报告有效，可自行根据实验设定sum_threshold指标，当有效指标数量超过sum_threshold则报告有效

2. **bug报告自动评估**：自动评估所有bug报告质量（文本量化为分数）

   描述、截图、点赞数、点踩数

   - 句子增益
     - 使用HanLP训练Word2vec模型DcovectorModel，利用余弦相似度计算句子相似度
     - 系统进行实验并人工确定相似度阈值document threshold，相似度大于该阈值的两个句子被认为是相同的句子，无实际语义的增益
     - 通过对比父子报告的所有句子，根据相似度筛选出子报告不同于附报告中任一句子的句子，该句子即为子报告文本的增益信息
   - 截图增益
     - 使用Lire提取截图CEDD或FCTH特征，并使用其提供的相似度度量方法计算图片相似度
     - 系统进行实验并人工确定相似度阈值image threshold，相似度大于该阈值的两张图片被认为是相同图片，无信息增益
     - 对比父子报告的所有截图，筛选出子报告不同于父报告中任一截图的截图，该截图即为子报告图片的增益信息
   - 协作增益：计算父子报告点赞点踩数的差异

   协作式众包测试中众包工人可单独或者Fork提交bug报告，bug报告包括单一状和树状报告两种。单一状报告没有父报告，树状报告有父报告，质量控制系统对两种报告采取不同的自动评分策略

   单一状报告自动评估：![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/E6A9E7FBECF665EDFB01B837AD3E256C.png)

   - 系统提取某次测试任务的所有单一状报告，对每个报告提取其质量属性BugAttribute类实例
   - 系统根据质量指标有效区间，选择每个指标集合中最右指标组成标准bug报告
   - 系统根据BugAttribute集合利用熵权法确定各个质量指标在平谷中所占的权重W
   - 利用灰色关联分析法计算每个报告质量指标与标准报告质量指标的关联度向量C，指标向量C与指标权重W的乘积m即为各个报告与标准报告的总关联度
   - 将m标准化到分数区间（0-10）即可得到每个报告的最终评分s，完成对于报告的评估

   树状报告自动评估：![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/06577DD8BF98218E6E73E683A9B2078A.png)

   - 原始评分：单一状报告自动评分得到报告树节点报告的分数s1
   - 子报告信息增益：使用信息增益评估方法得到子报告的信息增益InfoGain
   - 对于IndoGain中子报告的文本增益sentences，组合句子为文本并提取质量指标。若子报告的增益句子中含有质量指标，则增加子报告score1
   - 对于InfoGain中子报告的图片增益images，子报告每增加一张不同的截图，增加score2分数
   - 对于InfoGain中的likeCount，子报告得到的点赞数增加则增加score3分数，减少则减少
   - 对于InfoGain中的dissCount，子报告得到的点赞数增加则减少score3分数，减少则增加
   - s1经过信息增益导致的分数变化得到s2
   - 当s2<0，令s2=0；当s2>10，令s2=10

3. 反馈和监控：

   - 评估众包工人的每个操作并反馈：向众包工人反馈报告有效，或反馈报告无效和无效原因
   - 展示众包工人的失信行为和协作行为，共平台管理者识别和剔除恶意众包工人

4. 缺陷报告审核：提供缺陷报告人工审核服务，通过展示报告详细信息供众测系统管理者审核报告

#### 2.2.3众包测试报告聚合

1. 大量测试报告中存在较多的重复数据，增加了工作量，但描述相同的bug的不同报告也可能有更多的信息

2. Aggregator：对所有测试报告做聚类，相同或相似的报告聚类为同类

   Summarizer：对每一类测试报告做整合，将其中的相关信息以可视化的方式最大化呈现给开发者

## 3.AI测试

### 3.1AI测试概述

1. 智能软件

   - 算法对于人类来说是黑箱，不知道什么时候会出错，为什么会出错

     不可靠：在目标数据进行微小扰动，就有可能使得智能软件的判断结果出错→需要对智能软件进行测试，提早发现缺陷

2. **AI测试与传统测试的区别（重点）**

   - 传统软件的决策逻辑：程序代码控制决策逻辑

     智能软件决策逻辑：决策逻辑由深度学习模型结构、训练后得到权重节点共同组成

   - 传统软件测试旨在检测系统现有的行为与期望的行为之间的差异，一般步骤是面向待测软件构建一组测试用例（<输入，输出>），然后将这些用例交给待测软件执行，比较待测软件的实际输出与预期的输出是否相同，若不相符则表明软件存在缺陷。**通过控制流和数据流进行判断**

     - 测试语言：提供一种正确性标准检查被测程序是否存在缺陷
     - 测试覆盖：评估目标程序的测试充分性

   - AI测试：**通过数据驱动构建的参数化数值判断**。智能软件系统的缺陷往往不是显式的代码或参数错误，而是通过数据显示缺陷。数据驱动建模使得智能软件的行为会随着训练数据改变而改变，模型的统计性本质使得系统的输出具有不确定性，难以找到测试语言

3. AI测试的难点：

   - 数据量不够：大部分数据都用于模型训练，只有小部分数据用于测试，很难覆盖尽可能多的情况→采集更多数据、扩增样本数据
   - 低质量数据：
     - 在自动化地数据生成和扩增中，难保不会出现数据失真的情况，尽管它们能使系统出错但这些数据并不应该是系统关注的重点
     - 测试数据较大脱离了任务场景
   - 数据分布不均：导致测试遗漏了很多系统的某些功能上的缺陷
   - 不充分测试：不仅仅关注准确性等基础指标，还应该关注模型等其他方面的质量

4. 数据驱动的测试

   - 使⽤容量更⼤、更复杂的模型，效果更好的算法
   - 数据规模可以短时间内迅速扩⼤

### 3.2模糊测试（大概）

1. 内涵：只要测试执行次数够多+测试数据随机生成，就一定能触发概率低的偶然现象发生（大数定律）

2. 定义：通过向目标程序提供非预期的输入并监视异常结果来发现软件漏洞的方法

3. 流程![3](https://seek2.oss-cn-shanghai.aliyuncs.com/img/3.png)

4. 输入数据：①对已有数据样本进行变异②根据已知的协议或接口规范进行建模，生成测试用例

5. 监测的内容（输出）：断言失败、无效输入、异常崩溃、错误输出

6. ![4](https://seek2.oss-cn-shanghai.aliyuncs.com/img/4.png)

   - 种子集准备
     - 初始种⼦
     - 预处理
     - 种⼦打包形成语料集
     - 语料集筛选规则

   - 过程引导

     - 语料集采样：语料集采样根据模糊测试变异⽅法从送⼊过程引导的语料集中形成符合变异⽅法输⼊的种⼦元组。

     - 能量函数：旨在通过对语料集进⾏变异成功率检测实现在同样的测试计算资源尽可能⽣成多的能够成功变异的测试数据。

     - 数据变异：根据所选⽤的变异⽅法，对选取的原始测试数据施加扰动，⽣成新的测试输⼊。

     - 健康测试：根据所测试的程序制定了⼀定的规则⽤来检测模糊测试变异的测试数据是否有效。

   - 结果验证
     - 结果参照物：是否产⽣运⾏崩溃、结果参考物对⽐
     - 结果分析：覆盖率分析、传统反馈

#### 3.2.1测试数据生成

1. 文本数据生成

   - 基于生成：根据待测程序定义的文本生成的规则和模板，用以指导模糊测试生成文书测试数据

   - 基于变异：借助NLP处理已有的可以作为测试用例的数据，通过一定的变异规则如进行实体替换，来进行语料的增广

     - 加噪：在原数据基础上通过替换词、删除词等方式创造和源数据想类似的新数据

       ①同义词替换：在句子中随机抽取n个词，从同义词词典中随机抽取同义词，并进行替换

       ②随机插入：随去抽取一个词，在该词的同义词集合中随机选择一个，插入原句子中的随机位置。该过程可以重复n次

       ③随机交换：句子中，随机选择两个词，位置交换。该过程 可以重复n次

       ④句子中的每个词，以概率p随机删除

     - 回译：将原有数据翻译为其他语言再翻译回原语言

2. 图像数据生成

   - 基于生成：定义生成的规则和模板（如图像的大小、像素值的范围、通道数）
   - 基于变异：维持语义的前提下进行图像变换，比如对图像进行至多一次fangshi变换，而进行多次像素值的变换
     - 水平翻转垂直翻转
     - 旋转
     - 放大缩小
     - 裁剪
     - 平移
     - 高斯噪声

### 3.3图像扩增

1. 数据扩增：通过轻微变换现有数据或创建新的合成图像来得到新数据

2. 扩增的原则

   - 扩增后的标签保持不变，或根据扩增策略相应修改标签(6->9)
   - 扩增需要基于先验知识。针对不同任务和场景，数据扩增的策略不同
   - 不引入无关的数据

3. 医疗扩增：![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/A9B5480D52ECE84A6D6C5B6F48CF3C2D.png)

   - 医疗图像扩增的特点 

     - 图像中不同形式的细微结构可能代表某种病变 

     - 不能保证扩增的质量 

     - 不同疾病要使⽤不同的扩增⽅法 医疗图像扩增的难点 

   - 患者隐私保护,医学影像匮乏 

     - 共享临床数据困难 

     - 影像质量参差不⻬ 

     - 需要专家⼿动贴标签

#### 3.3.1图像扩增方法

1. 原样本扩增：将原图像作为一个整体进行常规的图像扩增变换来得到新样本
   - 几何变换：将一幅图像中的坐标位置映射到另一幅图像中的新坐标位置，本质是改变像素的空间位置，估算新空间位置上的像素值
   - 颜色空间变换
   - 像素点操作![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/293C1E1CD77F2E6291CDCDCF800E5ADD.png)
2. 单样本扩增：基于领域知识，对某一样本进行特征识别、分离、合成，在原样本基础上生成具有新特征的新样本
   - 特征识别：
     - 两阶段：找到可能包含物体的区域 -> 对该区域进⾏分类
     - 单阶段：图⽚缩放划分等分⽹络，并且卷积后过滤获得最后预测框。
   - 特征分离
   - 特征合成：基于规则、基于分割确定合成区域![img](https://seek2.oss-cn-shanghai.aliyuncs.com/img/32E406F23F9FB42E8708F3BCF6283D5B.png)
3. 多样本扩增：结合不同的样本进行扩增，变化更加多样
   - 样本级合成：标签a的特征 + 标签b的特征 = 标签a![5](https://seek2.oss-cn-shanghai.aliyuncs.com/img/5.png)
   - 特征级合成：将不同特征在同⼀张图上⾯重新排列组合
   - 标签降级：变成不同的特征